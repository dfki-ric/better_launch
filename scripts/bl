#!/usr/bin/env python3

"""
This script should be used as follows:

bl <package> <launchfile> <--launch-args>

- Autocomplete after bl will list available ROS2 packages.
- Automcplate after <package> will list launch files (.py, .xml, .yaml, .yml) and executable files in the package.
- A dash ("-") followed by autocomplete after <launchfile> should list launch args for better_launch launch files and declared args for ROS2 launch files.
"""

import sys
import os
import ast
import click
from docstring_parser import parse as parse_docstring

from ament_index_python.packages import (
    get_packages_with_prefixes,
    get_package_prefix,
    get_package_share_directory,
)

try:
    # Humble
    from ros2param.api import (
        get_parameter_value as get_parameter_value_humble,
        get_value as get_value_humble,
    )

    get_parameter_value = lambda s: get_parameter_value_humble(string_value=s)
    parameter_value_to_python = lambda p: get_value_humble(parameter_value=p)
except:
    # Jazzy
    from rclpy import get_parameter_value, parameter_value_to_python


from better_launch.utils.introspection import get_launchfunc_signature_from_file


class LaunchFile:
    @classmethod
    def from_file(cls, package: str, filepath: str) -> "LaunchFile":
        for launch_cls in [BetterLaunchFile, Ros2LaunchFile, ExecutableLaunchFile]:
            try:
                return launch_cls(package, filepath)
            except ValueError:
                pass

        raise ValueError(f"{filepath} is not a valid launch file")

    def __init__(
        self,
        package: str,
        launchfile: str,
        filepath: str,
        params: list[click.Option],
        doc: str,
    ):
        self.package = package
        self.launchfile = launchfile
        self.filepath = filepath
        self.params = params
        self.doc = doc or f"{package}/{os.path.basename(launchfile)}"

    def run(self, ctx: click.Context, **kwargs) -> None:
        raise NotImplementedError()


class BetterLaunchFile(LaunchFile):
    @classmethod
    def _get_launch_params_and_doc_bl(
        cls, filepath: str
    ) -> tuple[list[click.Option], str]:
        if not filepath.lower().endswith(".py"):
            raise ValueError("Not a python file")

        _, signature, doc = get_launchfunc_signature_from_file(filepath)
        if not signature:
            raise ValueError("Not a better_launch launch file")

        if doc:
            parsed_doc = parse_docstring(doc)
            launchfunc_doc = parsed_doc.short_description
            param_docstrings = {p.arg_name: p.description for p in parsed_doc.params}
        else:
            launchfunc_doc = ""
            param_docstrings = {}

        options = []
        for param in signature.parameters.values():
            default = None
            if param.default is not param.empty:
                default = param.default

            ptype = None
            if default is None and param.annotation is not param.empty:
                ptype = param.annotation

            options.append(
                click.Option(
                    [f"--{param.name}"],
                    type=ptype,
                    default=default,
                    show_default=True,
                    help=param_docstrings.get(param.name, None),
                )
            )

        return options, launchfunc_doc

    def __init__(self, package: str, filepath: str):
        params, doc = BetterLaunchFile._get_launch_params_and_doc_bl(filepath)
        launchfile = os.path.basename(filepath)
        super().__init__(package, launchfile, filepath, params, doc)

    def run(self, ctx: click.Context, **kwargs):
        print(
            f">> Delegating to better_launch: {self.package}/{self.launchfile}, args={kwargs}",
            flush=True,
        )

        # First argument becomes argv[0], so should be the program name
        args = ["python3", self.filepath]
        args.extend([f"--{key} {arg}" for key, arg in kwargs.items()])

        # This does NOT return and will replace our executable with the new executable in the same process
        os.execvp("python3", args)


class Ros2LaunchFile(LaunchFile):
    @classmethod
    def _get_launch_params_and_doc_ros2(
        cls, filepath: str
    ) -> tuple[list[click.Option], str]:
        if not filepath.lower().endswith(".py"):
            raise ValueError("Not a python file")

        try:
            with open(filepath, "r", encoding="utf-8") as f:
                source = f.read()

            tree = ast.parse(source)
        except:
            raise ValueError("Not valid python code")

        has_launch_func = False
        doc = None
        options = []

        def eval_arg(arg):
            try:
                return ast.literal_eval(arg)
            except:
                return None

        for node in ast.walk(tree):
            if (
                isinstance(node, ast.FunctionDef)
                and node.name == "generate_launch_description"
            ):
                doc = ast.get_docstring(node)
                has_launch_func = True

            elif isinstance(node, ast.Call):
                call_name = getattr(node.func, "id", getattr(node.func, "attr", None))
                if call_name == "DeclareLaunchArgument":
                    kwargs = {key.arg: key.value for key in node.keywords if key}
                    if node.args:
                        name = eval_arg(node.args[0])
                    else:
                        name = eval_arg(kwargs.get("name", None))

                    opt_doc = eval_arg(kwargs.get("description", None))
                    default = eval_arg(kwargs.get("default_value", None))
                    choices = eval_arg(kwargs.get("choices", None))

                    if default:
                        # Yes ROS2, I also think that simple things are boring and uninspiring...
                        default = parameter_value_to_python(
                            get_parameter_value(default)
                        )

                    if choices:
                        ptype = click.Choice(choices)
                    else:
                        ptype = type(default) if default is not None else None

                    options.append(
                        click.Option(
                            [f"--{name}"],
                            type=ptype,
                            help=opt_doc,
                            default=default,
                        )
                    )

        if not has_launch_func:
            raise ValueError("Not a ROS2 launch file")

        return options, doc

    @classmethod
    def _get_launch_params_and_doc_xml(
        cls, filepath: str
    ) -> tuple[list[click.Option], str]:
        # Not implemented yet"
        return [], None

    @classmethod
    def _get_launch_params_and_doc_yaml(
        cls, filepath: str
    ) -> tuple[list[click.Option], str]:
        # Not implemented yet
        return [], None

    def __init__(self, package: str, filepath: str):
        launchfile = os.path.basename(filepath)

        for func in [
            Ros2LaunchFile._get_launch_params_and_doc_ros2,
            Ros2LaunchFile._get_launch_params_and_doc_xml,
            Ros2LaunchFile._get_launch_params_and_doc_yaml,
        ]:
            try:
                params, doc = func(filepath)
                break
            except ValueError:
                pass
        else:
            raise ValueError("Not a ROS2 launch file")

        super().__init__(package, launchfile, filepath, params, doc)

    def run(self, ctx: click.Context, **kwargs):
        print(
            f">> Delegating to ROS2 launch: {self.package}/{self.launchfile}, args={kwargs}",
            flush=True,
        )

        # First argument becomes argv[0], so should be the program name
        args = ["ros2", "launch", self.filepath]
        args.extend([f"{key}:={arg}" for key, arg in kwargs.items()])

        # This does NOT return and will replace our executable with the new executable in the same process
        os.execvp("ros2", args)


class ExecutableLaunchFile(LaunchFile):
    def __init__(self, package, filepath):
        if not os.access(filepath, os.X_OK):
            raise ValueError("Not executable")

        launchfile = os.path.basename(filepath)
        params = []
        doc = None
        super().__init__(package, launchfile, filepath, params, doc)

    def run(self, ctx: click.Context, **kwargs):
        print(
            f">> Directly executing launch file: {self.package}/{self.launchfile}, args={kwargs}",
            flush=True,
        )

        # First argument becomes argv[0], so should be the program name
        args = [self.launchfile]
        args.extend(sys.argv[1:])

        # This does NOT return and will replace our executable with the new executable in the same process
        os.execvp(self.filepath, args)


class LaunchfileSelectionCLI(click.MultiCommand):
    def __init__(self, package: str, **kwargs):
        super().__init__(**kwargs)
        self._package = package
        self._package_path = get_package_prefix(package)

    def list_commands(self, ctx: click.Context) -> list[str]:
        executables = self._get_executables()
        return list(map(os.path.basename, executables))

    def get_command(self, ctx: click.Context, name: str) -> click.Command:
        executables = self._get_executables()
        candidates = [ex for ex in executables if os.path.basename(ex) == name]

        if not candidates:
            print(f"Launchfile {name} not found in package {self._package}")
            return None

        if len(candidates) > 1:
            print(
                f"Multiple executable files named {name} found in package {self._package}"
            )
            return None

        launchfile = LaunchFile.from_file(self._package, candidates[0])

        # return a launchfile command with launch args as its Options
        ctx.obj = {
            "launchfile": launchfile,
        }
        return click.Command(
            name,
            callback=click.pass_context(launchfile.run),
            params=launchfile.params,
            help=launchfile.doc,
        )

    def _get_executables(self, include_launchfiles: bool = True) -> list[str]:
        # list executable files inside our package
        if not self._package_path:
            print(f"Packge {self._package} could not be found")
            return []

        package_paths = [
            os.path.join(self._package_path, "lib", self._package),
            get_package_share_directory(self._package),
        ]
        executables = []

        for base_path in package_paths:
            for dirpath, dirnames, filenames in os.walk(base_path):
                dirnames[:] = [d for d in dirnames if not d.startswith(".")]
                dirnames.sort()

                # Look for executable files
                for filename in sorted(filenames):
                    path = os.path.join(dirpath, filename)
                    if os.access(path, os.X_OK):
                        executables.append(path)
                    elif include_launchfiles and (
                        filename.endswith((".py", ".xml", ".yaml", ".yml"))
                        or ".launch." in filename
                    ):
                        executables.append(path)

        return executables


class PackageSelectionCLI(click.MultiCommand):
    def list_commands(self, ctx: click.Context) -> list[str]:
        # list ROS2 packages
        return list(get_packages_with_prefixes().keys())

    def get_command(self, ctx: click.Context, name: str) -> click.Command:
        # return a the command that will handle selecting launch files from the package
        return LaunchfileSelectionCLI(name)


if __name__ == "__main__":
    PackageSelectionCLI().main()
